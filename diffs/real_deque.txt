* creating deque of size 0 *
size = 0
{  }

Map empty() = true

Map max_size() = 4611686018427387903
* construct and fill *
size = 6
{ (3), (3), (3), (3), (3), (3) }

* pushed {1, 4, 2, 7, 9} consecutively *
Front : 1, back : 9
size = 5
{ (1), (4), (2), (7), (9) }


* popped 2 values *
size = 3
{ (1), (4), (2) }


* inserted array {9, 10, 11, 12} before the 2nd index *
size = 7
{ (1), (4), (9), (10), (11), (12), (2) }


* erased dq[6] *
size = 6
{ (1), (4), (9), (10), (11), (12) }


* erased elements [2; 5[ *
size = 3
{ (1), (4), (12) }


* assigning array {4, 9, 18, 98, 7, 32, 1, -9, 5, 21} to dq *
size = 10
{ (4), (9), (18), (98), (7), (32), (1), (-9), (5), (21) }

* copy constructor / assignment operator '=' *  -->
-> success
-> success
* swap (both member and non-member) *  -->  success, success
* normal and reverse iteration *
4 9 18 98 7 32 1 -9 5 21 
21 5 -9 1 32 7 98 18 9 4 

* assigning from dereferenced non-const iterators *  -->  success
* dq.at(i) && dq[i] *  -->  success
* const and non-const overloads for op[] and at() *  -->  success, success
* out-of-range exception thrown when bound-checking with dq.at() *  -->  success
* iterators and relational operations *
beg = 42, end = 21
last > beg ? success
beg < last ? success
last < end() ? success
rbeg = 21, end = 42
rlast > rbeg ? success
rbeg < rlast ? success
rlast < rend() ? success

* iterators and constness *
-> success
-> success
-> success
-> success

* comparison operator overloads *
{ (yo), (ca), (va) }

{ (oui), (et), (toi) }

{ (le), (bon), (steak) }

{ (le), (cpp), (c cool) }

== --> success
!= --> success
>  --> success
>= --> success
<  --> success
<= --> success
